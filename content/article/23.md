+++
title = "PageCryptãƒ™ãƒ¼ã‚¹ã®HTMLæš—å·åŒ–ã‚’ç¢ºèªã™ã‚‹"
date = "2025-02-23"
description = "PageCrypt ã®å‹•ä½œåŸç†ã‚’è§£èª¬ã—ã€Python ã¨ JavaScript ã§ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¿è­·ã•ã‚ŒãŸHTMLã‚’æš—å·åŒ–ãƒ»å¾©å·åŒ–ã™ã‚‹ã€‚"
[taxonomies]
tags = ["cryptography"]
+++

HTMLãƒšãƒ¼ã‚¸ã‚’ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¿è­·ã—ãŸã„å ´åˆã€Basicèªè¨¼ã‚„Digestèªè¨¼ãªã©ã‚µãƒ¼ãƒãƒ¼è¨­å®šãŒå¿…è¦ãªæ‰‹æ³•ã‚’ä½¿ã†ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚
ã—ã‹ã—ã€"é™çš„ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ä¸Šã§å®Œçµã•ã›ãŸã„"ã¨ã„ã£ãŸã‚·ãƒ¼ãƒ³ã§ã¯ã€PageCrypt[^page_crypt]ã®ã‚ˆã†ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§å¾©å·ã™ã‚‹ä»•çµ„ã¿ãŒæœ‰ç”¨ã§ã™ã€‚

PageCryptã¯ã€HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’äº‹å‰ã«æš—å·åŒ–ã—ã€JavaScriptã§å¾©å·åŒ–ã™ã‚‹ã“ã¨ã§ã€ã‚µãƒ¼ãƒãƒ¼ã®è¿½åŠ è¨­å®šã‚’ä¸è¦ã«ã—ã¦ã„ã¾ã™ã€‚

æœ¬è¨˜äº‹ã§ã¯ã€Pythonã¨JavaScriptã§PageCryptç›¸å½“ã®å‡¦ç†ã‚’å†ç¾ã—ãªãŒã‚‰ã€AES-GCMæš—å·ã¨PBKDF2ï¼ˆã‚ã‚‹ã„ã¯argon2ï¼‰ã«ã‚ˆã‚‹ã‚­ãƒ¼å°å‡ºã‚’è§£èª¬ã—ã¾ã™ã€‚

Pythonã®æš—å·åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ `pycryptodome`[^pd] ã‚’ã€JavaScriptã®å¾©å·ã«ã¯ `Web Crypto API` ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

[TOC]

## å…¨ä½“ã®æµã‚Œ

ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ãƒ­ãƒ¼ã§ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¨å¹³æ–‡(HTML)ã‚’ç”¨ã„ã¦ã€AES-GCMã§æš—å·åŒ–ã—ã¾ã™ã€‚

![PBKDF2+AES-GCM](/image/023/PBKDF2_AES-GCM.png)

1. å¹³æ–‡ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ç”¨æ„ã™ã‚‹
2. PBKDF2ã‚’ç”¨ã„ã¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰éµ(key)ã‚’ç”Ÿæˆ
3. ç”Ÿæˆã—ãŸéµã‚’åˆ©ç”¨ã—ã¦ã€AES-BCMã§æš—å·åŒ–ã‚’è¡Œã†
4. saltã€IV[^iv]ã€æš—å·æ–‡ã¨èªè¨¼ã‚¿ã‚°(tag)ã‚’1ã¤ã«ã¾ã¨ã‚ã‚‹

ä¸Šè¨˜ãƒ•ãƒ­ãƒ¼ã‹ã‚‰ã‚‚ã‚ã‹ã‚‹ã‚ˆã†ã«ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ç›´æ¥AESã®éµã¨ã—ã¦ä½¿ã‚ãªã„ã§ã™ã€‚
ã‚ãã¾ã§ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’åˆ©ç”¨ã—ã€PBKDF2ã‚’é€šã—ã¦éµã‚’ä½œæˆã—ã€å®‰å…¨ã«æš—å·åŒ–ã™ã‚‹è¨­è¨ˆã«ãªã£ã¦ã„ã¾ã™ã€‚

å®Ÿéš›ã®é‹ç”¨ã§ã¯ã€Œsaltã€ã€ŒIVã€ã€Œæš—å·æ–‡ã€ã€Œèªè¨¼ã‚¿ã‚°ã€ã®ï¼”ã‚»ãƒƒãƒˆã‚’HTMLã«åŸ‹ã‚è¾¼ã¿ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€JavaScriptãŒãã‚Œã‚‰ã®æƒ…å ±ã‚’ä½¿ã£ã¦å¾©å·å‡¦ç†ã‚’è¡Œã„ã€ãƒšãƒ¼ã‚¸ã‚’å±•é–‹ã™ã‚‹ä»•çµ„ã¿ã§ã™ã€‚

## AES-GCM ã«ã‚ˆã‚‹æš—å·åŒ–/å¾©å·åŒ–

AESã«ã¯CBCã‚„CTRãªã©è¤‡æ•°ã®ãƒ¢ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã“ã§ã¯AES-GCM(Galois/Counter Mode)ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

AES-GCMã¯ã€èªè¨¼ã‚¿ã‚°ï¼ˆMACï¼‰ãŒè‡ªå‹•çš„ã«ç”Ÿæˆãƒ»æ¤œè¨¼ã•ã‚Œã‚‹ã€Œèªè¨¼ä»˜ãæš—å·ã€ã§ã‚ã‚Šã€æ”¹ã–ã‚“æ¤œçŸ¥ãŒæ¨™æº–ã§è¡Œãˆã‚‹ã®ãŒç‰¹å¾´ã§ã™ã€‚

ã¾ãšã¯ã€Œhelloã€ã‚’æš—å·åŒ–ãƒ»å¾©å·ã™ã‚‹ç°¡å˜ãªã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¾ã™ã€‚

~~~py
import base64
import os

from Crypto.Cipher import AES


def encrypt(key: bytes, plaintext: bytes) -> bytes:
    iv = os.urandom(12)
    cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return iv + ciphertext + tag

def decrypt(key: bytes, iv: bytes, ciphertext: bytes, tag: bytes) -> bytes:
    cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
    return cipher.decrypt_and_verify(ciphertext, tag)


if __name__ == "__main__":
    plaintext = b"hello"

    key = b"0"*16
    encrypted_data = encrypt(key, plaintext)

    final_encrypted_data = base64.b64encode(encrypted_data)
    print("Encrypted data:", final_encrypted_data)

    iv = encrypted_data[:12]
    ciphertext = encrypted_data[12:-16]
    tag = encrypted_data[-16:]
    print("Decrypted data:", decrypt(key, iv, ciphertext, tag))
~~~

~~~sh
# Derived Key: 30303030303030303030303030303030
# Encrypted data: b'7GYaE4mekELCvfQHhONbxe7JSejHy/nW/LfkQ5Fu9ks8'
# Decrypted data: b'hello'
~~~

"hello"ãŒæš—å·åŒ–ã•ã‚Œã€å¾©å·ã«ã‚ˆã‚Šå…ƒé€šã‚Š"hello"ã«æˆ»ã£ã¦ã„ã¾ã™ã€‚

### æ”¹ã–ã‚“æ¤œçŸ¥ã®ä¾‹

æš—å·æ–‡ã®ä¸€éƒ¨ã‚’æ”¹ã–ã‚“ã—ãŸå ´åˆã€èªè¨¼ã‚¿ã‚°ã¨ã®ç…§åˆãŒå¤±æ•—ã—ã€`.decrypt_and_verify()`ã¯ã‚¨ãƒ©ãƒ¼ã‚’åãã¾ã™ã€‚

è©¦ã—ã«æš—å·æ–‡ã®ä¸€éƒ¨ã‚’æ›¸ãæ›ãˆã¾ã™ã€‚

~~~py
key = b"0"*16

encrypted_data = bytearray(b"7GYaE4mekELCvfQHhONbxe7JSejHy/nW/LfkQ5Fu9ks8")
print("Decrypted data:", decrypt(key, encrypted_data))

encrypted_data[12] ^= 0x01  # ğŸ”¥
try:
    print("Decrypted data:", decrypt(key, encrypted_data))
except ValueError as e:
    print("Error:", e)
~~~

~~~sh
# Decrypted data: b'hello'
# Error: MAC check failed
~~~

ã“ã®ã‚ˆã†ã«ã€æ”¹ã–ã‚“ã‚’æ¤œçŸ¥ã—ã¦å¾©å·ã§ããªããªã‚Šã¾ã™ã€‚

### JavaScriptã§å¾©å·ã™ã‚‹

ä¸Šè¨˜Pythonã§æš—å·åŒ–ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ã€JavaScriptã®Web Crypto APIã§å¾©å·ã™ã‚‹ä¾‹ã§ã™ã€‚

~~~js
async function deriveKey() {
  const keyBytes = new Uint8Array(16).map((_, i) => "0".charCodeAt(0));

  return await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-GCM", length: 128 },
    false,
    ["decrypt"]
  );
}

async function decrypt(key, iv, ciphertextAndTag) {
  try {
    const decryptedArrayBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: iv },
      key,
      ciphertextAndTag
    );

    const decryptedText = new TextDecoder().decode(decryptedArrayBuffer);
    console.log(`Decrypted data: ${decryptedText}`);
  } catch (e) {
    console.error("å¾©å·ã‚¨ãƒ©ãƒ¼:", e);
  }
}

(async () => {
  const encryptedData = "7GYaE4mekELCvfQHhONbxe7JSejHy/nW/LfkQ5Fu9ks8";
  const binaryData = Uint8Array.from(atob(encryptedData), (c) =>
    c.charCodeAt(0)
  );

  const iv = binaryData.slice(0, 12);
  const ciphertextAndTag = binaryData.slice(12);

  const key = await deriveKey();
  decrypt(key, iv, ciphertextAndTag);
})();
~~~

~~~console
Decrypted data: hello
~~~

å•é¡Œãªãå¾©å·ã§ãã¦ã„ã¾ã™ã€‚

## PBKDF2

AES-GCMã§åˆ©ç”¨ã™ã‚‹éµã®ç”Ÿæˆã«ã¯ã€PBKDF2ã‚’ä½¿ã†ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚

PBKDF2ã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¨saltã‚’ç”¨ã„ã€ãƒãƒƒã‚·ãƒ¥è¨ˆç®—ã‚’è¤‡æ•°å›ç¹°ã‚Šè¿”ã™ã“ã¨ã§ã€æ”»æ’ƒã‚’å›°é›£ã«ã™ã‚‹ä»•çµ„ã¿ã§ã™ã€‚

AESéµã¯16ãƒã‚¤ãƒˆ(128ãƒ“ãƒƒãƒˆ)ã‚„32ãƒã‚¤ãƒˆ(256ãƒ“ãƒƒãƒˆ)ã®é•·ã•ãŒå¿…è¦ã§ã™ãŒã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯é•·ã•ã‚„å¼·åº¦ãŒãƒãƒ©ãƒãƒ©ãªã®ã§ã€PBKDF2ã§å®‰å…¨ã«éµã‚’å°å‡ºã—ã¾ã™ã€‚

ä»¥ä¸‹ã®ä¾‹ã§ã¯PBKDF2ã‚’10ä¸‡å›åå¾©ã—ã€AES-256ï¼ˆ32ãƒã‚¤ãƒˆï¼‰ã®éµã‚’å°å‡ºã—ã¦ã„ã¾ã™ã€‚

~~~py
from Crypto.Hash import SHA256
from Crypto.Protocol.KDF import PBKDF2


def derive_key(password: str, salt: bytes) -> bytes:
    return PBKDF2(
        password,
        salt,
        dkLen=32,
        count=100000,
        hmac_hash_module=SHA256,
        )
~~~

æš—å·åŒ–çµæœã«ã¯æš—å·æ–‡ã®å…ˆé ­ã«saltã‚‚åŠ ãˆã¦å‡ºåŠ›ã—ã€å¾©å·æ™‚ã¯ãã‚Œã‚’å–ã‚Šå‡ºã—ã¦åŒã˜éµå°å‡ºã‚’è¡Œã„ã¾ã™ã€‚

~~~py
password = "mypassword"
plaintext = b"hello"

salt = os.urandom(16)
key = derive_key(password, salt)
encrypted_data = encrypt(key, plaintext)

final_encrypted_data = base64.b64encode(salt + encrypted_data)

print("Salt:", salt.hex())
print("Derived Key:", key.hex())
print("Base64 Encoded Data:", final_encrypted_data)
~~~

~~~sh
# Salt: 8094f8bc4474837fbe7fd0a6b3777cd1
# Derived Key: 93c9bd309716836ce01b954297e4ca99a5c5d30a080fe3b0df09dbe92b1e1963
# Base64 Encoded Data: b'gJT4vER0g3++f9Cms3d80ZX2181OikMw7IADnsZlg11rqY8wqVrOsY2cCnANGWFq1g=='
~~~

JavaScriptå´ã§åŒã˜ãPBKDF2ã‚’ä½¿ãˆã°å¾©å·ã§ãã¾ã™ã€‚

~~~js
async function deriveKey(password, salt) {
  const encoder = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  return await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 100000,
      hash: "SHA-256",
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );
}

async function decrypt(key, iv, ciphertextAndTag) {
}

(async () => {
  const encryptedData =
    "gJT4vER0g3++f9Cms3d80ZX2181OikMw7IADnsZlg11rqY8wqVrOsY2cCnANGWFq1g==";
  const password = "mypassword";
  const binaryData = Uint8Array.from(atob(encryptedData), (c) =>
    c.charCodeAt(0)
  );
  const salt = binaryData.slice(0, 16);
  const iv = binaryData.slice(16, 28);
  const ciphertextAndTag = binaryData.slice(28);

  const key = await deriveKey(password, salt);
  decrypt(key, iv, ciphertextAndTag);
})();
~~~

~~~console
Decrypted data: hello
~~~

## argon2

ã‚ªãƒªã‚¸ãƒŠãƒ«ã®PageCryptã«ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€argon2ã‚’ä½¿ã£ãŸã‚­ãƒ¼å°å‡ºã«å·®ã—æ›¿ãˆã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

2015å¹´ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥ã‚³ãƒ³ãƒšãƒ†ã‚£ã‚·ãƒ§ãƒ³[^phc]ã®å„ªå‹è€…ã§ã‚ã‚‹Argon2ã¯ã€PBKDF2ã®ä»£æ›¿ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã§ã™ã€‚
ãŸã¨ãˆã°ã€Bitwardenã ã¨Argon2idã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™[^bit]ã€‚

ä»¥ä¸‹ã®ä¾‹ã§ã‚‚2idã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚

Pythonã§ã¯`argon2-cffi`[^argon2_cffi]ã€JavaScriptã§ã¯`argon2-browser`[^argon2-browser]ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

åŸºæœ¬çš„ãªéƒ¨åˆ†ã¯PBKDF2ã®å ´åˆã¨åŒã˜ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ã«éµã‚’ç”Ÿæˆã—ã¾ã™ã€‚

~~~py
from argon2.low_level import Type, hash_secret_raw


def derive_key(password: str, salt: bytes) -> bytes:
    return hash_secret_raw(
        secret=password.encode(),
        salt=salt,
        time_cost=3,
        memory_cost=65536,
        parallelism=1,
        hash_len=32,
        type=Type.ID,
    )
~~~

~~~sh
# Salt: d10b6d0d2f02808426efaedfc2453896
# Derived Key: 3d7b67a07cb91dce957eda7b2903502de7de8e68e0fa9f616278afcfe3f8d74d
# Base64 Encoded Data: b'0QttDS8CgIQm767fwkU4lvgFvJZ95BYFJPjPa/MKXwKh0LwEuZeye2BSzMiCD5r7ZQ=='
~~~

JavaScriptå´ã§ã¯ `argon2-browser`ã‚’CDNã§èª­ã¿è¾¼ã¿ã€åŒæ§˜ã«ã‚­ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§å¾©å·å¯èƒ½ã§ã™ã€‚

~~~js
async function deriveKey(password, salt) {
  const hash = await argon2.hash({
    pass: password,
    salt: salt,
    time: 3,
    mem: 65536,
    hashLen: 32,
    parallelism: 1,
    type: argon2.ArgonType.Argon2id,
  });

  return await crypto.subtle.importKey(
    "raw",
    new Uint8Array(hash.hash),
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );
}
~~~

~~~console
Decrypted data: hello
~~~

## ã¾ã¨ã‚

PageCryptã®ã‚ˆã†ã«ã€ã€ŒAES-GCM + PBKDF2 ã§HTMLã‚’æš—å·åŒ–ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§å¾©å·ã™ã‚‹ã€ã¨ã„ã†æµã‚Œã‚’ç¢ºèªã—ã¾ã—ãŸã€‚

æœ¬å®¶PageCryptå®Ÿè£…ã¯PBKDF2ã®ã¿ã§ã™ãŒã€argon2ã«ã‚‚å·®ã—æ›¿ãˆå¯èƒ½ã§ã‚ã‚Šã€å¿…è¦ã«å¿œã˜ã¦æ´¾ç”Ÿã•ã›ã‚‰ã‚Œã¾ã™ã€‚

é™çš„ãƒšãƒ¼ã‚¸ã§æ‰‹è»½ã«ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¿è­·ã‚’ã—ãŸã„ã¨ãã«å½¹ç«‹ã¡ã¾ã™ã€‚

## (ãŠã¾ã‘) è¿½åŠ èªè¨¼ãƒ‡ãƒ¼ã‚¿ï¼ˆAADï¼‰

AES-GCMã§ã¯ã€ã€ŒAADï¼ˆAdditional Authenticated Dataï¼‰ã€ã¨ã„ã†é ˜åŸŸã«ã€æš—å·åŒ–ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æœ¬ä½“ä»¥å¤–ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¼‰ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

AADã¯ã€æš—å·ã®å¼·ã•è‡ªä½“ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ãŒã€é€šä¿¡ã®å®‰å…¨æ€§ã«ã¯é–¢ä¿‚ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã‚„å—ä¿¡è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãªã©ã‚’ AAD ã«å«ã‚ãªã„ã¨ã€æ”»æ’ƒè€…ãŒè‡ªç”±ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¦ã—ã¾ã„ã¾ã™ã€‚
ãã®çµæœã€å¤ã„å®‰å…¨æ€§ã®ä½ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«å¤‰æ›´ã•ã‚Œã‚‹ãªã©ã®ãƒªã‚¹ã‚¯ãŒç”Ÿã˜ã¾ã™ã€‚

ãŸã ã€GCM ã®å‹•ä½œã‚’å¤‰ãˆã‚‹ã‚ˆã†ãªæƒ…å ±ã¯ã€èªè¨¼ã‚¿ã‚°ã®æ¤œè¨¼ã‚ˆã‚Šå‰ã«ãƒã‚§ãƒƒã‚¯ã—ã¦ãŠãæ–¹ãŒå®‰å…¨ã§ã™[^aad]ã€‚

~~~py
import os

from Crypto.Cipher import AES

key = b"0"*16
plaintext = b"hello"
aad = b"metadata123"
iv = os.urandom(12)

cipher = AES.new(key, AES.MODE_GCM, nonce=iv)

cipher.update(aad)
ciphertext, tag = cipher.encrypt_and_digest(plaintext)

cipher2 = AES.new(key, AES.MODE_GCM, nonce=iv)
try:
    print(cipher2.decrypt_and_verify(ciphertext, tag))
except ValueError as e:
    print(e)

cipher3 = AES.new(key, AES.MODE_GCM, nonce=iv)
cipher3.update(aad)
try:
    print(cipher3.decrypt_and_verify(ciphertext, tag))
except ValueError as e:
    print(e)s
~~~

## (ãŠã¾ã‘) ç”»åƒã®å¯¾å¿œ

HTMLå†…ã®ç”»åƒã‚‚æš—å·åŒ–ã—ãŸã„å ´åˆã€ç”»åƒã‚’base64ã§åŸ‹ã‚è¾¼ã‚€æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚

~~~py
path = Path("aiueo.png")
data = base64.b64encode(path.read_bytes()).decode()
element = f"data:image/png;base64,{data}"
~~~

ã‚ã¨ã¯ `<img src="data:image/png;base64,iVBORw0KGg..." />` ã¨ã„ã†å½¢ã§HTMLã«åŸ‹ã‚è¾¼ã‚ã°ã€ã²ã¨ã¤ã®HTMLãƒ•ã‚¡ã‚¤ãƒ«ã§å®Œçµã—ã¾ã™ã€‚

## å‚è€ƒ

[^page_crypt]: [https://github.com/MaxLaumeister/PageCrypt](https://github.com/MaxLaumeister/PageCrypt)

[^pd]: [https://pypi.org/project/pycryptodome/](https://pypi.org/project/pycryptodome/)

[^iv]: 12ãƒã‚¤ãƒˆã®é•·ã•ã®IV(nonce)ãŒã€"NIST SP 800-38D"ã«ã‚ˆã£ã¦æ¨å¥¨ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

[^bit]: [KDFã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  | Bitwarden](https://bitwarden.com/ja-jp/help/kdf-algorithms/)

[^argon2-browser]: WASMå®Ÿè£…ã®ã‚ˆã†ã§ã™ã€‚[https://cdnjs.com/libraries/argon2-browser](https://cdnjs.com/libraries/argon2-browser)

[^argon2_cffi]: [hynek/argon2-cffi: Secure Password Hashes for Python](https://github.com/hynek/argon2-cffi?tab=readme-ov-file)

[^aad]: [aes - Does AAD make GCM encryption more secure? - Cryptography Stack Exchange](https://crypto.stackexchange.com/questions/35727/does-aad-make-gcm-encryption-more-secure)

[^phc]: [Password Hashing Competition](https://www.password-hashing.net/)